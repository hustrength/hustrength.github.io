<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ICS2019-PA</title>
    <link href="/2020/12/23/ICS2019-PA/"/>
    <url>/2020/12/23/ICS2019-PA/</url>
    
    <content type="html"><![CDATA[<h1 id="课程设计概述"><a href="#课程设计概述" class="headerlink" title="课程设计概述"></a>课程设计概述</h1><h2 id="课设要求"><a href="#课设要求" class="headerlink" title="课设要求"></a>课设要求</h2><p>在代码框架中实现一个简化的 x86 模拟器 (NJU EMUlator)：</p><ul><li>可解释执行 X86 执行代码</li><li>支持输入输出设备</li><li>支持异常流处理</li><li>支持精简操作系统—-支持文件系统</li><li>支持虚存管理</li><li>支持进程分时调度</li></ul><p>最终在模拟器上运行“仙剑奇侠传”,让学生探究“程序在计算机上运行”的机理，掌握计算机软硬协同的机制，进一步加深对计算机分层系统栈的理解，梳理大学3年所学的全部理论知识，提升学生计算机系统能力。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>OS：20.04.2-Ubuntu</li><li>GCC：9.3.0</li><li>CPU：单核 Intel Core i5@2.4 GHz</li><li>Memory：4GB</li></ul><p><em>注：本次课设直接使用了老师提供的虚拟机镜像vdi</em></p><h2 id="报告内容说明"><a href="#报告内容说明" class="headerlink" title="报告内容说明"></a>报告内容说明</h2><p>本课程设计报告主要内容为：</p><ul><li>本人认为有关课设的重要知识点</li><li>比较复杂需要梳理的实验步骤</li><li>课设过程中本人犯的一些错误和需要注意的小陷阱</li><li>部分PA测试通过截图</li></ul><p><em>注：本次系统能力综合训练仅完成了x86架构的PA 1~PA 3，且报告内容并不包含所有实验步骤。</em></p><p><div style="page-break-after: always;"></div></p><h1 id="PA-1"><a href="#PA-1" class="headerlink" title="PA 1"></a>PA 1</h1><h2 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h2><p>PA1 的任务分为 3 个部分，依次实现NEMU调试器的一些指令。具体指令说明如下：</p><div class="table-container"><table><thead><tr><th>命令</th><th>格式</th><th>使用举例</th><th>说明</th></tr></thead><tbody><tr><td>帮助(1)</td><td><code>help</code></td><td><code>help</code></td><td>打印命令的帮助信息</td></tr><tr><td>继续运行(1)</td><td><code>c</code></td><td><code>c</code></td><td>继续运行被暂停的程序</td></tr><tr><td>退出(1)</td><td><code>q</code></td><td><code>q</code></td><td>退出NEMU</td></tr><tr><td>单步执行</td><td><code>si [N]</code></td><td><code>si 10</code></td><td>让程序单步执行<code>N</code>条指令后暂停执行,  当<code>N</code>没有给出时, 缺省为<code>1</code></td></tr><tr><td>打印程序状态</td><td><code>info SUBCMD</code></td><td><code>info r</code> <code>info w</code></td><td>打印寄存器状态 打印监视点信息</td></tr><tr><td>表达式求值</td><td><code>p EXPR</code></td><td><code>p $eax + 1</code></td><td>求出表达式<code>EXPR</code>的值</td></tr><tr><td>扫描内存(2)</td><td><code>x N EXPR</code></td><td><code>x 10 $esp</code></td><td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td></tr><tr><td>设置监视点</td><td><code>w EXPR</code></td><td><code>w *0x2000</code></td><td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td></tr><tr><td>删除监视点</td><td><code>d N</code></td><td><code>d 2</code></td><td>删除序号为<code>N</code>的监视点</td></tr></tbody></table></div><h2 id="PA-1-1"><a href="#PA-1-1" class="headerlink" title="PA 1.1"></a>PA 1.1</h2><p>从键盘上读入命令后，NEMU需要解析该命令，然后执行相关的操作。解析命令的目的是识别命令中的参数，例如在<code>si 10</code>的命令中识别出<code>si</code>和<code>10</code>，从而得知这是一条单步执行10条指令的命令。解析命令的工作是通过一系列的字符串处理函数来完成的，这里需要提及的函数为<code>strtok()</code>。</p><p><code>strtok()</code> 函数</p><ol><li>原型<br>char <em>strtok(char s[], const char </em>delim);</li><li>说明<br>当<code>strtok()</code>在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为\0 字符。</li><li>注意事项<br>使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。</li></ol><h2 id="PA-1-2"><a href="#PA-1-2" class="headerlink" title="PA 1.2"></a>PA 1.2</h2><p>PA 1.2需要实现指令<code>p</code>，以进行表达式求值。实现算术表达式的步骤如下：</p><ul><li>完成词法分析：<ul><li>为算术表达式中的各种token类型添加规则。</li><li>在成功识别出token后，将token的信息(类型，优先级，数字的字符串等)依次记录到<code>tokens</code>数组中。</li></ul></li><li><p>完成递归求值：</p><ul><li><p>实现函数<code>check_parentheses()</code>，用于判断表达式是否被一对匹配的括号包围着，同时检查表达式的左右括号是否匹配。</p></li><li><p>实现函数<code>get_main_op()</code>，用于选择出表达式中的主运算符。</p></li><li><p>对于<code>负号-</code>和<code>指针引用符号*</code>通过判断前一个token的优先级，来和<code>减号-</code>和<code>乘号*</code>区分。</p></li><li><p>实现函数<code>eval()</code>的逻辑，完成递归求值。</p></li></ul></li></ul><h2 id="PA-1-3"><a href="#PA-1-3" class="headerlink" title="PA 1.3"></a>PA 1.3</h2><p>PA 1.3需要实现监视点的创建和删除。主要涉及链表的操作，过程较为简单，略。</p><h2 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h2><ul><li><p>送分题 </p><ul><li>我选择的ISA是<code>x86</code>.</li></ul></li><li><p>理解基础设施 </p><ul><li><p>假设需要编译500次NEMU才能完成PA，且有90%的次数是用于调试。当没有实现简易调试器时，只能通过GDB对运行在NEMU上的客户程序进行调试。在每一次调试中，由于GDB不能直接观测客户程序, 需要花费30秒的时间来从GDB中获取并分析一个信息，并且需要获取并分析20个信息才能排除一个bug。那么，调试需要花费20*30*450=270000s=75h。</p></li><li><p>使用简易调试器，只需要花费10秒的时间从中获取并分析相同的信息，可以节约 2/3 的时间，只需花费75*2/3=50h。</p></li></ul></li><li><p>查阅手册（x86）</p><ul><li>EFLAGS寄存器中的CF位是什么意思?<ul><li>答案所在章节：2.3.4 Flags Register</li></ul></li><li>ModR/M字节是什么?<ul><li>答案所在章节：17.2.1 ModR/M and SIB Bytes</li></ul></li><li>mov指令的具体格式是怎么样的?<ul><li>答案所在章节：3.1 Data Movement Instructions</li></ul></li></ul></li><li><p>shell命令</p><ul><li><code>nemu/</code>下共有 5463 行代码。用的命令是 <code>find . -name &quot;\*.[ch]&quot;|xargs cat|wc -l</code></li><li>使用Git回到pa0，一共 4968 行，因此写了 495 行。</li><li>除去空行有 4898 行，用的命令是 <code>find . -name &quot;\*.[ch]&quot;|xargs cat|grep -v ^$|wc -l</code></li></ul></li><li>使用man<ul><li><code>-Wall</code>的作用是打开所有的警告，<code>-Werror</code>的作用是让所有的 warning 都以 error 显示。</li><li>使用它们的目的是在编译时尽可能地把潜在的 fault 直接显示为 failure，提早发现错误，减少调试时间。</li></ul></li></ul><p><div style="page-break-after: always;"></div></p><h1 id="PA-2"><a href="#PA-2" class="headerlink" title="PA 2"></a>PA 2</h1><h2 id="任务概述-1"><a href="#任务概述-1" class="headerlink" title="任务概述"></a>任务概述</h2><p>PA 2 的任务分为3个部分。PA 2.1和2.3实现众多x86指令，以支持Abstract machine(AM)。PA 2.3 实现AM的输入输出扩展。</p><h2 id="PA-2-1-amp-2-2"><a href="#PA-2-1-amp-2-2" class="headerlink" title="PA 2.1&amp;2.2"></a>PA 2.1&amp;2.2</h2><h3 id="指令执行过程梳理"><a href="#指令执行过程梳理" class="headerlink" title="指令执行过程梳理"></a>指令执行过程梳理</h3><p>一条指令在 NEMU 中执行过程分为<code>取码</code>，<code>译码</code>，<code>执行</code>，<code>更新 PC</code>四个阶段。以<code>mov</code>指令为例梳理整个指令执行流程。</p><p>从<code>cpu.c</code>开始，首先执行<code>exec_once()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">vaddr_t</span> <span class="hljs-title">exec_once</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  decinfo.seq_pc = cpu.pc;<br>  isa_exec(&amp;decinfo.seq_pc);<br>  update_pc();<br><br>  <span class="hljs-keyword">return</span> decinfo.seq_pc;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cpu.pc</code>的值保存在<code>decinfo.seq_pc</code>中，然后将该值的索引传进<code>isa_exec()</code>中，最后调用<code>update_pc()</code>更新pc值。指令的译码和执行在<code>isa_exec()</code>中，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isa_exec</span><span class="hljs-params">(<span class="hljs-keyword">vaddr_t</span> *pc)</span> </span>&#123;<br>  <span class="hljs-keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="hljs-number">1</span>);<br>  decinfo.opcode = opcode;<br>  set_width(opcode_table[opcode].width);<br>  idex(pc, &amp;opcode_table[opcode]);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>isa_exec()</code>从pc所指地方读取一个字节作为opcode并且保存在<code>decinfo.opcode</code>中。以下面这条<code>mov</code>指令为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">100000:    b8 34 12 00 00        mov    $0x1234,%eax<br></code></pre></td></tr></table></figure><p>其opcode是0xb8，接着通过opcode作为索引，查表opcode_table。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 0xb8 */</span>IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov),<br></code></pre></td></tr></table></figure><p>可知该<code>mov</code>指令译码函数为<code>IDEX(mov_I2r,mov)</code>。在<code>exec.h</code>中，我们可看到<code>IDEX宏</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXW(ex, w)         &#123;NULL, concat(exec_, ex), w&#125;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EX(ex)             EXW(ex, 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EMPTY              EX(inv)</span><br></code></pre></td></tr></table></figure><p>IDEX是宽度为0的<code>IDEXW</code>，而<code>IDEXW</code>翻译为的<code>concat</code>同样是个宏(定义在<code>macro.h</code>中)，其作用为将后面2个参数拼接起来。回到<code>IDEX(mov_I2r, mov)</code>这个具体实例，通过层层宏定义，<code>IDEX(mov_I2r,mov)</code>最终应该被翻译成：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;decode_mov_I2r, exec_mov, <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p><em>附：<code>I386 manual</code>中的一些缩写</em></p><blockquote><p>G：任一通用寄存器<br>E：任一通用寄存器/内存<br>r：指定的寄存器<br>b：字节<br>v：word\double word\quadword(16/32/64位,取决于CPU模式)<br>S：有符号<br>I：立即数</p></blockquote><p><em>因此，I2r释意为：该指令的操作为 立即数-&gt;指定的寄存器</em></p><p>再回到<code>isa_exec()</code>，现在执行<code>set_width(opcode_table[opcode].width);</code>。不过根据上面分析，这里宽度的值为0，也就是<code>set_width(0)</code>。根据<code>exec.c</code>中的<code>set_width()</code>函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_width</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (width == <span class="hljs-number">0</span>) &#123;<br>    width = decinfo.isa.is_operand_size_16 ? <span class="hljs-number">2</span> : <span class="hljs-number">4</span>;<br>  &#125;<br>  decinfo.src.width = decinfo.dest.width = decinfo.src2.width = width;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为width==0，而<code>is_operand_size_16</code>默认值是false，所以操作数的位宽都被设置为了4。但是一些变长指令，比如 <code>movw</code>，其执行函数将<code>is_operand_size_16</code>设置为true，因此操作数的宽度改为16位。</p><p>继续执行下一行<code>idex(pc, &amp;opcode_table[opcode]);</code>。<code>idex()</code>函数定义在<code>exec.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Instruction Decode and EXecute */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">idex</span><span class="hljs-params">(<span class="hljs-keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (e-&gt;decode)<br>    e-&gt;decode(pc);<br>  e-&gt;execute(pc);<br>&#125;<br></code></pre></td></tr></table></figure><p>作为例子的<code>mov</code>指令的译码函数是<code>decode_mov_I2r()</code>，不过这个函数也是宏定义的。</p><p><code>decode.h</code>中可以看到<code>make_DHelper(name)</code>宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span><br></code></pre></td></tr></table></figure><p>在<code>decode.c</code>中，<code>make_DHelper(mov_I2r)</code>就是译码函数<code>decode_mov_I2r()</code>的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">make_DHelper(mov_I2r) &#123;<br>  decode_op_r(pc, id_dest, <span class="hljs-literal">false</span>);<br>  decode_op_I(pc, id_src, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数里面调用了2个<code>decode_op_xxx</code>的函数，在<code>decode.c</code>中可看到这样一行宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *pc, Operand *op, bool load_val)</span><br></code></pre></td></tr></table></figure><p>类似的，在<code>decode.c</code>找到<code>make_DopHelper(r)</code>和<code>make_DopHelper(I)</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">make_DopHelper</span><span class="hljs-params">(r)</span> </span>&#123;<br>  op-&gt;type = OP_TYPE_REG;<br>  op-&gt;reg = decinfo.opcode &amp; <span class="hljs-number">0x7</span>;<br>  <span class="hljs-keyword">if</span> (load_val) &#123;<br>    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width);<br>  &#125;<br><br>  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="hljs-string">&quot;%%%s&quot;</span>, reg_name(op-&gt;reg, op-&gt;width));<br>&#125;<br><br><span class="hljs-comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span><br><br><span class="hljs-comment">/* Ib, Iv */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">make_DopHelper</span><span class="hljs-params">(I)</span> </span>&#123;<br>  <span class="hljs-comment">/* pc here is pointing to the immediate */</span><br>  op-&gt;type = OP_TYPE_IMM;<br>  op-&gt;imm = instr_fetch(pc, op-&gt;width);<br>  rtl_li(&amp;op-&gt;val, op-&gt;imm);<br><br>  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="hljs-string">&quot;$0x%x&quot;</span>, op-&gt;imm);<br>&#125;<br></code></pre></td></tr></table></figure><p>先将<code>make_DopHelper(r)</code>翻译如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">decode_op_r</span> <span class="hljs-params">(<span class="hljs-keyword">vaddr_t</span> *pc, Operand *op, <span class="hljs-keyword">bool</span> load_val)</span> </span>&#123;<br>  op-&gt;type = OP_TYPE_REG;<br>  op-&gt;reg = decinfo.opcode &amp; <span class="hljs-number">0x7</span>;<br>  <span class="hljs-keyword">if</span> (load_val) &#123;<br>    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width);<br>  &#125;<br><br>  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="hljs-string">&quot;%%%s&quot;</span>, reg_name(op-&gt;reg, op-&gt;width));<br>&#125;<br></code></pre></td></tr></table></figure><p>此处为<code>mov</code>指令经过层层宏定义解释的最终操作。该函数将op的类型赋值为OP_TYPE_REG，即标注为寄存器，寄存器的编号是<code>opcode &amp; 0x7</code>，例子中opcode为0xb8，所以寄存器编号是0，而0号寄存器就是EAX，load_val为false所以跳过。</p><p>这里还需说明一下<code>rtl_xxx</code>函数，它们使用寄存器传输语言实现跨平台操作，定义在<code>include/isa/rtl.h</code>文件和<code>include/rtl</code>目录中，初始框架只实现了几个，还有很多需要我们自行补充。</p><p>弄清了<code>mov</code>指令的执行过程，其他所有指令的实现并不困难。均可以按照I386手册中的详细介绍，填写opcode_table，实现译码函数，执行函数。在这里就不对其他指令的具体实现情况进行详细叙述了。</p><p><em>附：各种宏定义说明</em></p><div class="table-container"><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td><code>nemu/include/macro.h</code></td><td></td></tr><tr><td><code>str(x)</code></td><td>字符串<code>&quot;x&quot;</code></td></tr><tr><td><code>concat(x, y)</code></td><td>token<code>xy</code></td></tr><tr><td><code>nemu/include/cpu/decode.h</code></td><td></td></tr><tr><td><code>id_src</code></td><td>全局变量<code>decinfo</code>中源操作数成员的地址</td></tr><tr><td><code>id_src2</code></td><td>全局变量<code>decinfo</code>中2号源操作数成员的地址</td></tr><tr><td><code>id_dest</code></td><td>全局变量<code>decinfo</code>中目的操作数成员的地址</td></tr><tr><td><code>make_DHelper(name)</code></td><td>名为<code>decode_name</code>的译码辅助函数的原型说明</td></tr><tr><td><code>nemu/src/isa/$ISA/decode.c</code></td><td></td></tr><tr><td><code>make_DopHelper(name)</code></td><td>名为<code>decode_op_name</code>的操作数译码辅助函数的原型说明</td></tr><tr><td><code>nemu/include/cpu/exec.h</code></td><td></td></tr><tr><td><code>make_EHelper(name)</code></td><td>名为<code>exec_name</code>的执行辅助函数的原型说明</td></tr><tr><td><code>print_asm(...)</code></td><td>将反汇编结果的字符串打印到缓冲区<code>log_asmbuf</code>中</td></tr><tr><td><code>suffix_char(width)</code></td><td>操作数宽度<code>width</code>对应的后缀字符(仅x86使用)</td></tr><tr><td>`print_asm_template[1</td><td>2</td><td>3](instr)`</td><td>打印单/双/三目操作数指令<code>instr</code>的反汇编结果</td></tr></tbody></table></div><hr><h3 id="寄存器传输语言RTL说明"><a href="#寄存器传输语言RTL说明" class="headerlink" title="寄存器传输语言RTL说明"></a>寄存器传输语言RTL说明</h3><p>在NEMU中, RTL指令有两种：</p><p>一种是RTL基本指令(在<code>nemu/include/rtl/rtl.h</code>中定义)，它们的特点是不需要使用临时寄存器，可以看做是CPU执行过程中最基本的操作。不同的ISA都可以使用RTL基本指令，因此它们属于ISA无关的代码。RTL基本指令包括：</p><ul><li>立即数读入<code>rtl_li</code></li><li>寄存器传输<code>rtl_mv</code></li><li>32位寄存器-寄存器类型的算术/逻辑运算, 包括<code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code>, 这些运算的定义用到了<code>nemu/include/rtl/c_op.h</code>中的C语言运算</li><li>被除数为64位的除法运算<code>rtl_i?div64_[q|r]</code></li><li>guest内存访问<code>rtl_lm</code>和<code>rtl_sm</code></li><li>host内存访问<code>rtl_host_lm</code>和<code>rtl_host_sm</code></li><li>关系运算<code>rtl_setrelop</code>, 具体可参考<code>nemu/src/cpu/relop.c</code></li><li>跳转, 包括直接跳转<code>rtl_j</code>, 间接跳转<code>rtl_jr</code>和条件跳转<code>rtl_jrelop</code></li><li>终止程序<code>rtl_exit</code>(在<code>nemu/src/monitor/cpu-exec.c</code>中定义)</li></ul><p>第二种RTL指令是RTL伪指令，它们是通过RTL基本指令或者已经实现的RTL伪指令来实现的。RTL伪指令又分两类， 包括：</p><ul><li><p>ISA无关的RTL伪指令(在<code>nemu/include/rtl/rtl.h</code>中定义)</p><ul><li>32位寄存器-立即数类型的算术/逻辑运算, 包括<code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i</code></li><li>其它常用功能, 如按位取反<code>rtl_not</code>, 符号扩展<code>rtl_sext</code>等</li></ul></li><li><p>ISA相关的RTL伪指令(在<code>nemu/src/isa/$ISA/include/isa/rtl.h</code>中定义)</p><ul><li>通用寄存器访问<code>rtl_lr</code>和<code>rtl_sr</code></li><li>ISA相关性较强的功能(如x86的溢出和进/借位判断, EFLAGS标志位访问等)</li></ul></li></ul><hr><h3 id="x86指令识别"><a href="#x86指令识别" class="headerlink" title="x86指令识别"></a>x86指令识别</h3><p>一个字节最多只能区分256种不同的指令形式. 当指令形式的数目大于256时, 我们需要使用另外的方法来识别它们。x86中有主要有两种方法来解决这个问题:</p><ul><li>一种方法是使用转义码(escape code)。x86中有一个2字节转义码<code>0x0f</code>，当指令<code>opcode</code>的第一个字节是<code>0x0f</code>时，表示需要再读入一个字节才能决定具体的指令形式(部分条件跳转指令就属于这种情况)。后来随着各种SSE指令集的加入，使用2字节转义码也不足以表示所有的指令形式了，x86在2字节转义码的基础上又引入了3字节转义码，当指令<code>opcode</code>的前两个字节是<code>0x0f</code>和<code>0x38</code>时，表示需要再读入一个字节才能决定具体的指令形式。</li><li>另一种方法是使用<code>ModR/M</code>字节中的扩展opcode域来对<code>opcode</code>的长度进行扩充。有些时候, 读入一个字节也还不能完全确定具体的指令形式，这时候需要读入紧跟在<code>opcode</code>后面的<code>ModR/M</code>字节，把其中的<code>reg/opcode</code>域当做<code>opcode</code>的一部分来解释，才能决定具体的指令形式。x86把这些指令划分成不同的指令组(instruction group)，在同一个指令组中的指令需要通过<code>ModR/M</code>字节中的扩展opcode域来区分。</li></ul><p>因此，对于opcode相同的不同指令，使用ext_opcode进行区分。make_group宏进行二次译码，对相同opcode，不同ext_opcode的指令进行区分。</p><p>x86指令一般格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----------+-----------+-----------+--------+------+------+------+------------+-----------+<br>|<span class="hljs-string">instruction</span>|<span class="hljs-string"> address-  </span>|<span class="hljs-string">  operand- </span>|<span class="hljs-string">segment </span>|<span class="hljs-string">opcode</span>|<span class="hljs-string">ModR/M</span>|<span class="hljs-string"> SIB  </span>|<span class="hljs-string">displacement</span>|<span class="hljs-string"> immediate </span>|<br>|<span class="hljs-string">  prefix   </span>|<span class="hljs-string">size prefix</span>|<span class="hljs-string">size prefix</span>|<span class="hljs-string">override</span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">            </span>|<span class="hljs-string">           </span>|<br>|<span class="hljs-string">-----------+-----------+-----------+--------+------+------+------+------------+-----------</span>|<br>|<span class="hljs-string">   0 OR 1  </span>|<span class="hljs-string">  0 OR 1   </span>|<span class="hljs-string">   0 OR 1  </span>|<span class="hljs-string"> 0 OR 1 </span>|<span class="hljs-string">1 OR 2</span>|<span class="hljs-string">0 OR 1</span>|<span class="hljs-string">0 OR 1</span>|<span class="hljs-string"> 0,1,2 OR 4 </span>|<span class="hljs-string">0,1,2 OR 4 </span>|<br>|<span class="hljs-string"> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>|<br>|<span class="hljs-string">                                     number of bytes                                      </span>|<br>+------------------------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>接着，给出指令中<code>ModR/M</code>字节和<code>SIB</code>字节的格式，它们是用来确定指令的操作数的。当mod域取值为3的时候，r/m表示的是寄存器，否则r/m表示的是内存。reg和r/m解释为通用寄存器编码，用来表示其中一个操作数。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">ModR/M byte<br>7    6    5    4    3    2    1    0<br><span class="hljs-code">+--------+</span>-------------<span class="hljs-code">+-------------+</span><br>|  mod   | reg/opcode  |     r/m     |<br><span class="hljs-code">+--------+</span>-------------<span class="hljs-code">+-------------+</span><br><br>SIB (scale index base) byte<br>7    6    5    4    3    2    1    0<br><span class="hljs-code">+--------+</span>-------------<span class="hljs-code">+-------------+</span><br>|   ss   |    index    |    base     |<br><span class="hljs-code">+--------+</span>-------------<span class="hljs-code">+-------------+</span><br></code></pre></td></tr></table></figure><p>根据以上指令格式，可以使用联合并指定成员的占位大小，以表示opcode, ModR_M, SIB，进而进行指令的识别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">uint8_t</span> R_M       :<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">uint8_t</span> reg       :<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">uint8_t</span> mod       :<span class="hljs-number">2</span>;<br>  &#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">uint8_t</span> dont_care  :<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">uint8_t</span> opcode    :<span class="hljs-number">3</span>;<br>  &#125;;<br>  <span class="hljs-keyword">uint8_t</span> val;<br>&#125; ModR_M;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">uint8_t</span> base   :<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">uint8_t</span> index  :<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">uint8_t</span> ss    :<span class="hljs-number">2</span>;<br>  &#125;;<br>  <span class="hljs-keyword">uint8_t</span> val;<br>&#125; SIB;<br></code></pre></td></tr></table></figure><hr><h3 id="变长参数的使用"><a href="#变长参数的使用" class="headerlink" title="变长参数的使用"></a>变长参数的使用</h3><p>在实现<code>sprintf()</code>函数时，需要用到边长参数：</p><p>变长参数va_list, va_start, va_arg, va_end使用步骤：</p><ol><li>定义一个va_list类型的变量，变量是指向参数的指针。</li><li>va_start初始化刚定义的变量，第二个参数是最后一个显式声明的参数。</li><li>va_arg返回变长参数的值，第二个参数是该变长参数的类型。</li><li>va_end将a)定义的变量重置为NULL。</li></ol><p>以上宏定义在<code>stdarg.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">type <span class="hljs-title">va_arg</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">   va_list arg_ptr,</span></span><br><span class="hljs-function"><span class="hljs-params">   type </span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_end</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">   va_list arg_ptr </span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_start</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">   va_list arg_ptr,</span></span><br><span class="hljs-function"><span class="hljs-params">   prev_param </span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="PA-2-3"><a href="#PA-2-3" class="headerlink" title="PA 2.3"></a>PA 2.3</h2><p>PA框架提供的代码是模块化的，要在NEMU中加入设备的功能，只需要在<code>nemu/include/common.h</code>中定义宏<code>HAS_IOE</code>。定义后，<code>init_device()</code>函数会对设备进行初始化。重新编译后，运行NEMU时会弹出一个新窗口，用于显示VGA的输出。</p><p>PA 2.3需要实现的设备有<code>串口</code>，<code>时钟</code>，<code>键盘</code>，<code>VGA</code>，设备寄存器的地址定义在<code>nexus-am/am/include/nemu.h</code>中。仔细阅读手册，这些设备的实现并不困难，但需要对内联汇编有所了解。</p><p>带有C/C++表达式的内联汇编格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm__　__volatile__(<span class="hljs-string">&quot;Instruction List&quot;</span> : Output : Input : Clobber/Modify);<br></code></pre></td></tr></table></figure><p>由于占位符前面使用一个百分号(%)，为了区别占位符和寄存器，GCC规定在带有C/C++表达式的内联汇编中，”Instruction List”中直接写出的寄存器前必须使用两个百分号(%%)。</p><p>以PA 2.3为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;inl %1, %0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(data) : <span class="hljs-string">&quot;d&quot;</span>((<span class="hljs-keyword">uint16_t</span>)port))</span></span>;<br></code></pre></td></tr></table></figure><p>Instruction List是inl %1, %0 ，其中%1指代”d”((uint16_t)port)也就是dx，%0指代”=a”(data)也就是eax，最后输入的来源是port变量，输出的值保存在了data中。</p><h2 id="部分测试结果"><a href="#部分测试结果" class="headerlink" title="部分测试结果"></a>部分测试结果</h2><p><strong>一键回归测试结果：</strong></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 21.25.29.png" alt="Screen Shot 2021-01-14 at 21.25.29" style="zoom: 33%;" align="left" /></p><p><strong>microbranch测试结果：</strong></p><p><em>注：CPU为单核 Intel Core i5@2.4 GHz</em></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 17.04.24.png" alt="Screen Shot 2021-01-14 at 17.04.24" style="zoom:33%;" align="left" /></p><p><strong>typing游戏测试结果：</strong></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 21.29.30.png" alt="Screen Shot 2021-01-14 at 21.29.30" style="zoom:20%;" align="left"/></p><h2 id="必答题-1"><a href="#必答题-1" class="headerlink" title="必答题"></a>必答题</h2><ul><li><p>RTFSC 请整理一条指令在NEMU中的执行过程</p><ul><li>详见<a href="#PA 2.1&amp;2.2">分点PA 2.1&amp;2.2</a></li></ul></li><li><p>编译与链接1 </p><ul><li>单独去掉static和inline中的一个可以正常编译。同时去掉static和inline会报错<code>multiple definition</code>。static 修饰的函数不能被外部文件调用，因此其他文件可以定义重名函数。inline 修饰的函数不会出现在符号表中，在调用位置直接展开替换，因此可以在其他文件定义重名函数。</li><li>编写一个static inline修饰的函数并编译，若其未出现在符号表中，则可以验证以上结论。</li></ul></li><li><p>编译与链接2</p><ul><li>使用 grep -c -r “dummy”指令查看，共有 83 个 dummy 实体。</li><li>此时有84个dummy实体。如果有多个弱符号，则选择其中之一，多出来的一个是在 <code>debug.h</code> 中加入的。</li><li>发生报错<code>redefinition of “dummy”</code>，其原因是如果同时进行初始化将使得它们都成为强符号。</li></ul></li><li><p>了解Makefile</p><ul><li>在敲下<code>make</code>后，<code>make</code>程序会寻找当前目录下的<code>Makefile</code>或者<code>makefile</code>文件，根据其中定义的依赖关系，检查是否有文件更新，如果有的话，根据依赖关系将<code>.c</code>文件编译生成<code>.o</code>文件，再链接<code>.o</code>文件生成可执行文件。</li><li><code>nemu/</code>目录下的<code>Makefile</code>文件首先对ISA检测，确保ISA有效，接下来定义了 <code>include</code>,<code>build</code>,<code>obj</code> 和 <code>binary</code> 文件的绝对路径以及编译选项。然后寻找源文件在 <code>src/</code> 目录下的.c 文件，忽略 <code>isa/</code> 目录。然后再继续寻找<code>isa/</code> 目录下所选择的 isa 所包含的<code>.c</code> 文件。接下来是循环编译过程。最后是 <code>make run</code>，<code>make clean</code> 等常见命令。</li><li>使用<code>-n</code>选项，可以看到<code>make</code>使用GCC编译链接。 </li></ul></li></ul><p><div style="page-break-after: always;"></div></p><h1 id="PA-3"><a href="#PA-3" class="headerlink" title="PA 3"></a>PA 3</h1><h2 id="任务概述-2"><a href="#任务概述-2" class="headerlink" title="任务概述"></a>任务概述</h2><p>PA 3 整体实现一个简单的操作系统<code>Nanos-lite</code>：PA 3.1 实现中断和异常，PA 3.2 实现系统调用，PA 3.3 实现简易的文件系统。</p><h2 id="PA-3-1"><a href="#PA-3-1" class="headerlink" title="PA 3.1"></a>PA 3.1</h2><p>PA 3.1需要实现x86中断指令<code>int</code>。首先需要创建<code>IDT(中断描述符表)</code>数组，并实现<code>lidt</code>指令完成<code>IDT</code>的设置。之后，需要实现<code>raise_intr()</code>函数，以进行中断响应操作。</p><p><code>raise_intr()</code>触发异常的硬件响应过程：</p><ol><li><p>从<code>IDTR</code>中读出<code>IDT</code>的首地址</p></li><li><p>根据异常号在<code>IDT</code>中进行索引, 找到一个门描述符</p></li><li><p>将门描述符中的offset域组合成异常入口地址</p></li><li><p>依次将<code>eflags</code>， <code>cs</code>(代码段寄存器)， <code>eip</code>(也就是PC)寄存器的值压栈</p></li><li><p>根据<code>irq</code>跳转到异常入口地址</p></li></ol><p>根据irq跳转到异常入口地址后，程序需先保存上下文。而对于x86保存上下文包括：</p><ul><li>触发异常时的PC和处理器状态。对于x86来说就是<code>eflags</code>，<code>cs</code>和<code>eip</code>。而x86的异常响应机制已经将他们提前保存在堆上。</li><li>异常号。对于x86，由软件保存，无需保存在堆上。</li><li>地址空间。这是为PA4准备的，PA3中为一个占位符<code>$0</code>。</li></ul><p><em>注：保存上下文之后，还需压栈<code>%esp</code>(上下文结构体指针)</em></p><p>根据系统调用的过程，可知栈内容如下：</p><blockquote><p>低字节 |  $esp |<br>​            |    $0   |<br>​            |  $edi  |<br>​            |  $esi   |<br>​            |  $ebp |<br>​            |  $esp  |<br>​            |  $ebx  |<br>​            |  $edx  |<br>​            |  $ecx  |<br>​            |  $eax  |<br>​            |    irq   |<br>​            |    eip   |<br>​            |     cs    |<br>​高字节 | eflags |</p></blockquote><p>根据栈内容，可知结构体<code>_Context</code>中变量声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Context</span> &#123;</span><br>    <span class="hljs-comment">/* PA 3.1 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">AddressSpace</span> *<span class="hljs-title">as</span>;</span><br>    <span class="hljs-keyword">uintptr_t</span> edi, esi, ebp, esp, ebx, edx, ecx, eax;<br>    <span class="hljs-keyword">int</span> irq;<br>    <span class="hljs-keyword">uintptr_t</span> eip,cs,eflags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，对各寄存器压栈即对上下文结构体成员进行赋值。</p><h2 id="PA-3-2"><a href="#PA-3-2" class="headerlink" title="PA 3.2"></a>PA 3.2</h2><p>实现系统调用首先需要实现<code>loader()</code>函数。其作用是把程序加载到指定内存位置。</p><p>为了实现<code>loader()</code>，需要明白ELF文件的组织形式。在C语言中，<code>ELF文件头部</code>和<code>程序头部</code>结构分别定义为<code>Elf32_Ehdr</code>和<code>Elf32_Phdr</code>。下面给出<code>Elf32_Ehdr</code>和<code>Elf32_Phdr</code>中一些重要字段的含义解释：</p><div class="table-container"><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>e_phoff</td><td>首个程序段的偏移地址</td></tr><tr><td>e_phnum</td><td>程序段的个数</td></tr><tr><td>e_entry</td><td>虚拟入口点</td></tr><tr><td>p_type</td><td>程序类型，仅当其值为PT_LOAD时，才加载程序</td></tr><tr><td>p_offset</td><td>该段首个bit对于整个程序的偏移地址</td></tr><tr><td>p_vaddr</td><td>该段首个bit将被加载到内存中的虚拟地址</td></tr><tr><td>p_filesz</td><td>该段在整个程序中所占用的大小</td></tr><tr><td>p_memsz</td><td>该段在内存映像中占用的大小</td></tr></tbody></table></div><p>ELF头部文件的offset为0，从elf头部信息中提取出<code>e_phoff</code>和<code>e_phnum</code>，也就是首个程序段偏移地址和程序段个数，再从首偏移地址连续读<code>e_phnum</code>次，即可完成整个程序的加载。</p><p>对于每个程序段需要进行两步处理：</p><ol><li>把<code>p_offset</code>开始的<code>p_filesz</code>个字节的程序拷贝到从<code>p_vaddr</code>开始的内存中。</li><li>将<code>[p_vaddr+p_filesz, p_vaddr+p_memsz)</code>区间对应的物理区间清零。</li></ol><h2 id="PA-3-3"><a href="#PA-3-3" class="headerlink" title="PA 3.3"></a>PA 3.3</h2><p>PA 3.3实现一个简易的文件系统，需要实现<code>fs_open()</code>，<code>fs_close()</code>，<code>fs_read()</code>，<code>fs_write()</code>，<code>fs_lseek()</code>函数；还需要将设备(<code>串口</code>，<code>键盘</code>，<code>时钟</code>，<code>VGA</code>)抽象为文件，实现设备文件的读写操作。该过程较为简单，PA手册指导步骤也很详尽，就不在此赘述。</p><h2 id="仙剑奇侠传测试结果"><a href="#仙剑奇侠传测试结果" class="headerlink" title="仙剑奇侠传测试结果"></a>仙剑奇侠传测试结果</h2><p><strong><code>Nanos-lite</code>加载<code>/bin/init</code>程序，进入程序选择界面：</strong></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 22.41.05.png" alt="Screen Shot 2021-01-14 at 22.41.05" style="zoom:30%;" align="left" /></p><p><strong>运行仙剑奇侠传，并开始新的游戏：</strong></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 22.43.28.png" alt="Screen Shot 2021-01-14 at 22.43.28" style="zoom:30%;" align="left"/></p><p><strong>仙剑奇侠传进行读档：</strong></p><p><img src="/Users/hustrength/Desktop/Screen Shot 2021-01-14 at 22.50.31.png" alt="Screen Shot 2021-01-14 at 22.48.35" style="zoom:30%;" align="left"/></p><h2 id="必答题-2"><a href="#必答题-2" class="headerlink" title="必答题"></a>必答题</h2><ul><li><p>理解上下文结构体的前世今生 (见PA3.1阶段)</p><ul><li>详见<a href="#PA 3.1">分点PA 3.1</a></li></ul></li><li><p>理解穿越时空的旅程 (见PA3.1阶段)</p><ul><li>系统调用<code>_yield()</code>触发自陷操作，<code>raise_intr()</code>函数依次将<code>eflags</code>，<code>cs</code>， <code>eip</code>压栈，从<code>IDTR</code>寄存器中读出<code>IDT</code>的首地址，在<code>IDT</code>中索引找到门描述符，将其中的 offset 域组合成异常入口地址，跳转到异常入口地址。接着，将中断号<code>irq</code>压栈，跳转到<code>__am_asm_trap()</code>函数。该函数压栈各寄存器，以保存上下文。然后操作系统根据中断号分发事件，再分别处理事件，最后恢复上下文，返回断点。</li></ul></li><li>hello程序是什么, 它从而何来, 要到哪里去 (见PA3.2阶段)<ul><li>hello 从<code>.c</code>文件被编译链接成<code>ELF</code>文件，一开始在<code>ramdisk</code>的偏移位置为 0 的地方(实现文件系统后，由文件的<code>disk_offset</code>确定)。<code>loader()</code>函数加载文件，将 <code>ELF</code>文件需要执行的程序加载到指定的内存位置。由系统执行其第一条程序语句，最后调用<code>SYS_write</code>系统调用输出。</li></ul></li><li>仙剑奇侠传究竟如何运行 <ul><li>仙剑奇侠传程序在<code>PAL_SplashScreen()</code>中调用<code>VIDEO_UpdateScreen()</code>更新屏幕，进一步调用<code>SDL_UpdateRect()</code>，而其中的<code>redraw()</code>调用的<code>NDL_Render()</code>渲染用到的函数是<code>Nanos-lite</code>提供的 <code>fwrite()</code>。<code>Nanos-lite</code>将 VGA 抽象成文件，进行写入。而<code>NEMU</code>用<code>AM</code>提供的 I/O 接口把文件内容显示到屏幕上。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>代码</tag>
      
      <tag>课设</tag>
      
      <tag>PA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/16/hello-world/"/>
    <url>/2020/12/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hustrength.github.io/">Sihao Ren’s blog</a>! This is my first post!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
